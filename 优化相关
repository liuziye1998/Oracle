闩相关概念
    kcbgtcr是Oracle rdbms中重要的获取一致性读的函数，其含义为Kernal Cache Buffer GeT Cosistents Read，显然该函数存在两种获取
cache buffers chains的方式即kslbegin shared和excl。与之相对应的是kcbgcur: kslbegin，kcbgcur的含义为Kernel Cache Buffer Get Current，
该函数用以获取当前块以便修改，也就是"写"；很显然kcbgcur: kslbegin函数只有以excl排他方式持有child cache buffers chains latch的必要)，
原因在于虽然是查询语句但同样需要修改buffer header结构，譬如修改tch抢手度、holder list的hash变量us_nxt、us_prv以及waiter list的hash
变量wa_prv、wa_nxt等。换而言之读读是会引起Latch free:cache buffers chains等待的，而非许多人认为的仅有读写、写写会导致缓存链闩争用。

pin锁：用来确保数据的一致性

逻辑读详解
    我们都知道,数据块是oracle最基本的读写单位,但用户所需要的数据,并不是整个块,而是块中的行,或列.当用户发出SQL语句时,此语句被解析执行完毕，
就开始了数据的抓取阶段,在此阶段,服务器进程会先将行所在的数据块从数据文件中读入buffer cache,这个过程叫做物理读.物理读,每读取一个块,就算一次
物理读.当块被送进buffer cache后,并不能立即将块传给用户,因为用户所需要的并不是整个块,而是块中的行.从buffer cache的块中读取行的过程,就是逻辑
读.为了完成一次逻辑读,服务器进程先要在hash表中查找块所在的buffer cache 链.找到之后,需要在这个链上加一个cache buffer chains 闩,加闩成功之后,
就在这个链中寻找指定的块,并在块上加一个pin锁.并释放cache buffer chains闩.然后就可以访问块中的行了.服务器进程不会将块中所有满足条件的行一次取
出,而是根据你的抓取命令,每次取一定数量的行.这些行取出之后,会经由PGA传给客户端用户.行一旦从buffer cache中取出,会话要释放掉在块上所加的PIN.
本次逻辑读就算结束.如果还要再抓取块中剩余的行,服务器进程要再次申请获得cache bufffer链闩.再次在块上加PIN.这就算是另外一次逻辑读咯.也就是说,
服务器进程每申请一次cache buffer链闩,就是一次逻辑读.而每次逻辑读所读取的行的数量,可以在抓取命令中进行设置.
     逻辑读和Cache buffer chains闩关系密切，TOM曾有文章提到，进程每申请一次Cache buffer chains闩，就是一次逻辑读。但是，逻辑读并不等同
于Cache buffer chains闩，每次逻辑读，在9i中至少需要获得两Cache buffer chains闩。逻辑读是指在Hash表中定位块的这个过程。

DB TIME=DB Wait time + DB CPU time  
根据awr报告分析DB time
  查看头部相关参数
    elapsed:表示自然流逝的时间
    DB time：表示数据库调用花费的时间
  查看load profile 相关参数 
    DB time(s):每自然秒，DB time 对应为多少秒
    DB cpu(s): 每自然秒，CPU 对应的消耗时间
      设db time为43.1秒  db cpu 为0.1秒 elapsed为10分钟
      可推算出db time总耗时为43.1*60*10/60=431分钟
             db cpu总耗时为0.1*60*10/60=1分钟
             db wait time=431-1=430分钟
      验算
        通过查看top5事件中的首要事件的time  dbtime百分比  avg wait三个参数进行验算
        avg wait与db time - db cpu 的值接近   time / dbtime 与dbtime百分比的值接近

set autotrace 
    SET AUTOTRACE OFF ---------------- 不生成AUTOTRACE 报告，这是缺省模式
    SET AUTOTRACE traceonly EXPLAIN ------ AUTOTRACE只显示SQL的执行计划
    SET AUTOTRACE traceonly STATISTICS -- 只显示执行结果的数量和资源消耗（统计信息）
    SET AUTOTRACE ON ----------------- 包含执行计划和统计信息，执行结果数量
    SET AUTOTRACE TRACEONLY ------ 只显示SQL执行结果的数量，执行计划和资源消耗（统计信息）
        Statistics
        ----------------------------------------------------------
        1728  recursive calls
            0  db block gets  从buffer cache中读取的block的数量
        600161  consistent gets  逻辑读次数 从buffer cache中读取的undo数据的block的数量
            0  physical reads  物理读次数 从磁盘读取的block的数量
            0  redo size  DML生成的redo的大小
            673  bytes sent via SQL*Net to client
            492  bytes received via SQL*Net from client
            2  SQL*Net roundtrips to/from client
            42  sorts (memory)  在内存执行的排序量
            0  sorts (disk)  在磁盘上执行的排序量
            1  rows processed  sql语句处理或返回了多少行，能直观的看出来，这个sql能不能优化。

优化器分类：RBO和CBO
    相同点：首先解析有索引的列值，一致性索引的逻辑读次数始终会比非一致性索引的次数少一次，连表查询时，from右边的表为主表，左边的
        附表

    索引全扫描的条件之一：目标索引列的属性是not null 


查询某表的最后一次统计信息
    select table_name,blocks,num_rows（记录数）,to_char(last_analyed,'yyyymmdd hh24:mi:ss') from dba_tables where table_name='';

查询某表的真实记录数信息
    select count(*) from 用户名.表名

查询某表的索引情况
    select index_name,column_name,column_position from dba_ind_columns where table_name ='表名'；

对某表收集统计信息
    exec dbms_stats.gather_table_stats(ownname=>'用户名',tabname=>'表名',cascade=>true,no_invaliadate=>false,degree=>4);
    exec dbms_stats.gether_table_stats(ownname=>'用户名',tabname=>'表名',method_opt=>'for all columns size 1',cascade=>ture);
查询系统级别optimizer_mode的值
    select name,value from V$parmeter where name='optimizer_mode';

查询会话级别optimizer_mode的值
    oradebug setospid <process ID>
    oradebug unlimit
    oradebug dump processstate 10
    oradebug tracefile_name
    从产生的trace文件中查看

设置系统级别optimizer_mode的值
    alter system set optimizer_mode=xxx

设置会话级别optimizer_mode的值
    alter session set optimizer_mode=xxx

查看执行计划的方式
    1. explain plan
    2. dbms_xplan包
    3. sqlplus 的autotrace 
    4. 10046事件
    5. 10053事件
    6. awr报告或者statspack报告
    7. 一些脚本，如display_cursor_9i.sql等
    (DML语言中select可能只是解析而未被执行)

    explain plan语法详细
        explain plan for SQL语句 ;
        select * from table(dbms_xplan.display)

    dbms_xplan包的用法
        select * from table(dbms_xplan.display)
        select * from table(dbms_xplan.display_cursor(null,null,'advanced'))作用于刚刚执行的SQL语句 
        select * from table(dbms_xplan.display_cursor('sql_id/hash_value',child_cursor_number,'advanced'))根据sql_id/hash_value和
            child_cursor_number查看执行计划   作用域仅限SQL所在的child_cursor还存在于shared pool中
        select * from table(dbms_xplan.display_awr('sql_id"))根据SQL id查看其历史的执行计划，无法查询到执行步骤相对应的谓词条件

    10046事件
        1. 当前会话中激活10046事件
        2. 当前会话中执行目标SQL语句
        3. 关闭10046事件
        Oracle会将目标SQL的执行计划和资源消耗写入当前会话所对应的trace文件中，此文件的命名格式为‘实例名_ora_当前会话的spid.trc';此文件将保存在user_dump_dest
        所代表的目录下生成，其生成的是裸文件，使用tkprof命令翻译裸文件

        激活方法
            1. alter session set events '10046 trace name context forever,level 12';
            2. oradebug event 10046 trace name context forever,level 12;
        关闭方法
            1. alter session set events '10046 trace name context off;
            2. oradebug event 10046 trace name context off;

如何查看执行计划
    从最开头一直连续往右看，直到看见并列的位置，对于不并列的，靠右的先执行，对于并列的从上往下看，上面的先执行

执行计划 
    与表访问相关的执行计划
        全表扫描在执行计划中对应的关键字是table access full 
        rowid扫描对应的执行计划的关键字为table access by user rowid 或table access by index rowid (取决于SQL计划的关键字和目标表中是否有索引)

    与B树索引相关的执行计划（列值不能为空值 not null）
        索引唯一性扫描对应关键字为index unique scan
            近适用于where条件中是等值查询的SQL语句，其返回结果至多只有一条
        索引范围扫描对应关键字为index range scan
            目标SQL语句中where条件有一定的查询范围如between <  > >= <=等，同等搜索条件下范围扫描至少会比唯一性扫描的逻辑读次数多一次
        索引全扫描对应关键字为index full scan
            按照顺序依次对索引进行扫描，该方法既能对扫描结果达到排序的效果，又能同时避免对该索引值列真正的排序
        索引快速全扫描对应关键字为index fast full scan
            此方法只适用于CBO，可使用多块读，也可以并行执行，返回的结果不一定是有序的
        索引跳跃式扫描对应关键字为index skip scan
            此方法适用于where条件中没有对索引所在前导列指定条件，而对索引其他列指定条件时，，此方法适用于所有的复合索引

    与位图索引相关的执行计划
        创建位图索引关键字 create bitmap 索引名 on 表名(列名)
        优势：
            1. 被索引的列的distinct值较少，位图索引更节省存储空间
            2. 在多个列上创建索引，同等条件下更节省存储空间
            3. 快速处理一些包含各种and或or的条件查询的事情了
        适用条件
            1. 数据相同量大，相同量占总量比例高

        位图索引单键值扫描 bitmap index single value   
        位图索引范围扫描 bitmap index range scan
        位图索引全扫描 bitmap index full scan
        位图索引快速全扫描 bitmap index fast full scan
        位图按位与 bitmap and 
        位图按位或 bitmap or
        位图按位减 bitmap minus

    与表连接相关的执行计划
        排序合并连接对应的关键字是sort join和merge join
        嵌套循环连接对应的关键字是 nested loops
        哈希连接对应的关键字是 hash join 
            哈希半连接 hash join semi
        与反连接所对应的关键字是anti 连接方法不同对应的关键字可分为sort join anti, merge join anti, nested loops anti
        与半连接所对应的关键字是semi 连接方法不同对应的关键字可分为sort join semi, merge join semi, nested loops semi
            半连接会对连接结果进行必要的去重，即对表执行半连接的查询计划时会自动对查询结果进行必要的去重

    其他执行计划
        and-equal又称index merge,指如果where条件里出现了多个针对不同列的等值条件，且这些列上都有单键值的索引，则Oracle会以相应的单个
    等值条件去分别扫描这些索引，然后合并这些单个索引所得到的rowid集合，在从这些集合中筛选值相同的rowid再用筛选过的这些rowid回表得到目标
    SQL的最终执行结果
        and_equal对应关键字为and_equal

        index join 
        对应关键字为index join 

        视图合并view
        对应关键字为view
            如果能做视图合并SQL计划里不一定会出现view关键字，若不能做视图合并SQL计划里一定会出现view关键字，主要看谓词信息(prediacte 
        information)里面提示的内容

        filter过滤是一种改良的嵌套循环连接
        
        sort排序，通常以组合方式出现，比如下列几种
            1. sort aggreate 不一定进行排序
            2. sort unique              是否进行排序主要看统计信息中sorts(memory)和sorts(disk),上同，下同
            3. sort join 
            4. sort group by 
            5. sort order by 
            6. buffer sort 不一定进行排序 /验证是否排序，需要根据目标SQL真实执行计划中的#key值来确定，若值大于0则进行了排序

        union/union all 联合查询
            union：以并集的方式将连个表合并，且做好去重和排序
            union all：以并集的方式将表合并，不会进行去重和排序

        concat
            concat就是in_list扩展或or扩展
            执行计划中对应的关键字是concatenation
            in-list iterator  in-list迭代执行计划中对应的关键字为 inlist iterator

        层次查询(hierarchical queries)
            connect by 


稳定执行计划
    使用SPM 或者SQL profile来稳定执行计划

    SQL profile直译为SQL 概要  （被动执行）
    目的：
        1. 稳定执行计划
        2. 在不能修改目标SQL的SQL文本的情况下使目标SQL语句按指定的执行计划执行
    分类：
        automatic类型
            可以在不更改目标SQL的情况下更改其执行计划
        manual类型
            可以在不更改目标SQL的情况下更改其执行计划，同时可以很好的稳定目标SQL的执行计划
    
    SPM SQL PLAN Management  (主动稳定执行计划，且可以持续更新计划)
        启用后每一个SQL都会存在对应的SQL plan baseline，若有多个执行计划就有多个SQL plan baseline ，
        dba_sql_plan_baselines中列enabled和accepted用来判断SQL plan baseline所对应的执行计划能否被使用
        若enabled accepted的值均为yes则对应的SQL plan baseline的执行计划才能被启用，若有多个值为yes的SQL plan baseline则Oracle
        会从中选择成本值最小的执行计划来执行该SQL语句

        启用方式
            自动捕获： 
                optimizer_capture_sql_plan_baselines此参数用于控制是否开启自动捕获SQL plan baseline，默认为false,不捕获
                    将其值设为true之后Oracle会对此参数影响的范围内所有重复执行的SQL自动捕获SQL plan baseline，且第一次捕获的SQL
                    值均为yes
                optimizer_use_sql_plan_baselines此参数用于控制是否启用SMP ，默认值为true启用，此参数可以在会话和系统
                    级别修改
        更新执行计划可将要执行计划的enabled和accepted的值设为yes，将正在执行的计划中的值设为no即可


查看当前session的session id 
    select sid from V$mystat where rownum<2;
查看当前session id对应的session address 
    select saddr from V$session where sid=144;
查看当前session address产生的transaction总数
    select count(*) from V$transaction where ses_addr='';
查看当前session产生的transaction锁住的对象总数
    select count(*) from V$locked_object;
查看当前transaction 锁住的对象的object id
    select object_id from V$locked_object;
查看object id所对应的对象信息
    select owner,object_name from dba_objects where object_id=xxx;

清空共享池
    alter system flush shared_pool;


库缓存（library cache）：是共享池中的一块内存区域，主要作用是缓存刚刚执行过的SQL语句和pl/sql语句所对应的执行计划、解析树、pcode、
mcode等对象，当同样的语句再次被执行的时候，就可以利用已经缓存在库缓存的相关对象，无需从头开始，提高了语句在重复执行时的效率
    库缓存对象library cache object：所有的库缓存对象都是以库缓存对象句柄的结构存储在库缓存中，Oracle通过访问相关的库缓存对象句柄
  来访问对应的库缓存对象
    库缓存对象句柄library cache object handle：以哈希表的方式存储在库缓存中，Oracle通过相关的哈希运算存储访问对应的库缓存对象句柄
        常用属性介绍
            name：表示库缓存对象句柄对应的库缓存对象的名称，若是SQL语句对应的库缓存对象句柄，则name的值就是该SQL的SQL文本
                若是表对应的库缓存对象句柄，则那name的值就是该表的表名
            namespace：表示库缓存对象句柄对应的库缓存对象所在的分组名，不同类型的库缓存对象所对应的库缓存对象句柄的namespace值
                可能相同
    库缓存对象句柄链表library cache object handles：
    data heap是库缓存中一块连续的内存区域，由Oracle动态分配，大小不是固定不变的，一个库缓存对象有多个data heap，但每个data heap之间是独立的，没有关联关系


cursor游标与绑定变量
    游标分类
        shared cursor：指缓存在库缓存里的SQL语句和匿名PL/SQL语句所对应的库缓存对象，对应库缓存对象句柄的namespace值为crsr
            分类：
                parent cursor父游标：目标SQL的SQL文本会存储在其对应的库缓存对象句柄的属性name中
                child cursor 子游标：目标SQL的解析树和执行计划存储在其对应的库缓存对象句柄的heap6中
            Oracle数据库里，任意一个目标SQL一定会同时对应两个shared cursor，分别为parent cursor和child cursor,其中parent cursor存储该SQL的SQL文本信息
          child cursor存储该SQL的解析树和执行计划，这种双游标的方式可以有效降低对应hash bucket中库缓存对象句柄链表的长度
            通过V$sqlarea视图可以查询到目标SQL的游标数，列version_count的值表示某个parent cursor所拥有的child cursor的数量
                select sql_id,version_count from V$sqlarea where ....;
            通过V$SQL视图查询目标SQL的所有child cursur
                select plan_hash_value,child_number from V$sql where sql_id='xxxx';
    
        session cursor 

    硬解析（hard parse）
        分类：
            1. 在库缓存中找不到匹配的parent cursor，此时Oracle会从头解析目标SQL，并重新生成一个parent cursor和child cursor并挂在对应的hash bucket
            2. 匹配到parent cursor但匹配不到child cursor,此时Oracle会从头解析SQL新生成一个child cursor并 将其挂在相应的parent cursor
        危害：
            1. 会导致shared pool latch的争用，会影响系统的性能和可扩展性（通常表现为CPU占用率居高不下）
            2. 导致库缓存相关latch和mutex的争用