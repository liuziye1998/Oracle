闩相关概念
    kcbgtcr是Oracle rdbms中重要的获取一致性读的函数，其含义为Kernal Cache Buffer GeT Cosistents Read，显然该函数存在两种获取
cache buffers chains的方式即kslbegin shared和excl。与之相对应的是kcbgcur: kslbegin，kcbgcur的含义为Kernel Cache Buffer Get Current，
该函数用以获取当前块以便修改，也就是"写"；很显然kcbgcur: kslbegin函数只有以excl排他方式持有child cache buffers chains latch的必要)，
原因在于虽然是查询语句但同样需要修改buffer header结构，譬如修改tch抢手度、holder list的hash变量us_nxt、us_prv以及waiter list的hash
变量wa_prv、wa_nxt等。换而言之读读是会引起Latch free:cache buffers chains等待的，而非许多人认为的仅有读写、写写会导致缓存链闩争用。

pin锁：用来确保数据的一致性

逻辑读详解
    我们都知道,数据块是oracle最基本的读写单位,但用户所需要的数据,并不是整个块,而是块中的行,或列.当用户发出SQL语句时,此语句被解析执行完毕，
就开始了数据的抓取阶段,在此阶段,服务器进程会先将行所在的数据块从数据文件中读入buffer cache,这个过程叫做物理读.物理读,每读取一个块,就算一次
物理读.当块被送进buffer cache后,并不能立即将块传给用户,因为用户所需要的并不是整个块,而是块中的行.从buffer cache的块中读取行的过程,就是逻辑
读.为了完成一次逻辑读,服务器进程先要在hash表中查找块所在的buffer cache 链.找到之后,需要在这个链上加一个cache buffer chains 闩,加闩成功之后,
就在这个链中寻找指定的块,并在块上加一个pin锁.并释放cache buffer chains闩.然后就可以访问块中的行了.服务器进程不会将块中所有满足条件的行一次取
出,而是根据你的抓取命令,每次取一定数量的行.这些行取出之后,会经由PGA传给客户端用户.行一旦从buffer cache中取出,会话要释放掉在块上所加的PIN.
本次逻辑读就算结束.如果还要再抓取块中剩余的行,服务器进程要再次申请获得cache bufffer链闩.再次在块上加PIN.这就算是另外一次逻辑读咯.也就是说,
服务器进程每申请一次cache buffer链闩,就是一次逻辑读.而每次逻辑读所读取的行的数量,可以在抓取命令中进行设置.
     逻辑读和Cache buffer chains闩关系密切，TOM曾有文章提到，进程每申请一次Cache buffer chains闩，就是一次逻辑读。但是，逻辑读并不等同
于Cache buffer chains闩，每次逻辑读，在9i中至少需要获得两Cache buffer chains闩。逻辑读是指在Hash表中定位块的这个过程。

DB TIME=DB Wait time + DB CPU time  
根据awr报告分析DB time
  查看头部相关参数
    elapsed:表示自然流逝的时间
    DB time：表示数据库调用花费的时间
  查看load profile 相关参数 
    DB time(s):每自然秒，DB time 对应为多少秒
    DB cpu(s): 每自然秒，CPU 对应的消耗时间
      设db time为43.1秒  db cpu 为0.1秒 elapsed为10分钟
      可推算出db time总耗时为43.1*60*10/60=431分钟
             db cpu总耗时为0.1*60*10/60=1分钟
             db wait time=431-1=430分钟
      验算
        通过查看top5事件中的首要事件的time  dbtime百分比  avg wait三个参数进行验算
        avg wait与db time - db cpu 的值接近   time / dbtime 与dbtime百分比的值接近

set autotrace 
    SET AUTOTRACE OFF ---------------- 不生成AUTOTRACE 报告，这是缺省模式
    SET AUTOTRACE traceonly EXPLAIN ------ AUTOTRACE只显示SQL的执行计划
    SET AUTOTRACE traceonly STATISTICS -- 只显示执行结果的数量和资源消耗（统计信息）
    SET AUTOTRACE ON ----------------- 包含执行计划和统计信息，执行结果数量
    SET AUTOTRACE TRACEONLY ------ 只显示SQL执行结果的数量，执行计划和资源消耗（统计信息）
        Statistics
        ----------------------------------------------------------
        1728  recursive calls
            0  db block gets  从buffer cache中读取的block的数量
        600161  consistent gets  逻辑读次数 从buffer cache中读取的undo数据的block的数量
            0  physical reads  物理读次数 从磁盘读取的block的数量
            0  redo size  DML生成的redo的大小
            673  bytes sent via SQL*Net to client
            492  bytes received via SQL*Net from client
            2  SQL*Net roundtrips to/from client
            42  sorts (memory)  在内存执行的排序量
            0  sorts (disk)  在磁盘上执行的排序量
            1  rows processed  sql语句处理或返回了多少行，能直观的看出来，这个sql能不能优化。

优化器分类：RBO和CBO
    相同点：首先解析有索引的列值，一致性索引的逻辑读次数始终会比非一致性索引的次数少一次，连表查询时，from右边的表为主表，左边的
        附表

    索引全扫描的条件之一：目标索引列的属性是not null 


查询某表的最后一次统计信息
    select table_name,blocks,num_rows（记录数）,to_char(last_analyed,'yyyymmdd hh24:mi:ss') from dba_tables where table_name='';

查询某表的真实记录数信息
    select count(*) from 用户名.表名

查询某表的索引情况
    select index_name,column_name,column_position from dba_ind_columns where table_name ='表名'；

对某表收集统计信息
    exec dbms_stats.gather_table_stats(ownname=>'用户名',tabname=>'表名',cascade=>true,no_invaliadate=>false,degree=>4);
    exec dbms_stats.gether_table_stats(ownname=>'用户名',tabname=>'表名',method_opt=>'for all columns size 1',cascade=>ture);
查询系统级别optimizer_mode的值
    select name,value from V$parmeter where name='optimizer_mode';

查询会话级别optimizer_mode的值
    oradebug setospid <process ID>
    oradebug unlimit
    oradebug dump processstate 10
    oradebug tracefile_name
    从产生的trace文件中查看

设置系统级别optimizer_mode的值
    alter system set optimizer_mode=xxx

设置会话级别optimizer_mode的值
    alter session set optimizer_mode=xxx

查看执行计划的方式
    1. explain plan
    2. dbms_xplan包
    3. sqlplus 的autotrace 
    4. 10046事件
    5. 10053事件
    6. awr报告或者statspack报告
    7. 一些脚本，如display_cursor_9i.sql等
    (DML语言中select可能只是解析而未被执行)

    explain plan语法详细
        explain plan for SQL语句 ;
        select * from table(dbms_xplan.display)

    dbms_xplan包的用法
        select * from table(dbms_xplan.display)
        select * from table(dbms_xplan.display_cursor(null,null,'advanced'))作用于刚刚执行的SQL语句 
        select * from table(dbms_xplan.display_cursor('sql_id/hash_value',child_cursor_number,'advanced'))根据sql_id/hash_value和
            child_cursor_number查看执行计划   作用域仅限SQL所在的child_cursor还存在于shared pool中
        select * from table(dbms_xplan.display_awr('sql_id"))根据SQL id查看其历史的执行计划，无法查询到执行步骤相对应的谓词条件

    10046事件
        1. 当前会话中激活10046事件
        2. 当前会话中执行目标SQL语句
        3. 关闭10046事件
        Oracle会将目标SQL的执行计划和资源消耗写入当前会话所对应的trace文件中，此文件的命名格式为‘实例名_ora_当前会话的spid.trc';此文件将保存在user_dump_dest
        所代表的目录下生成，其生成的是裸文件，使用tkprof命令翻译裸文件

        激活方法
            1. alter session set events '10046 trace name context forever,level 12';
            2. oradebug event 10046 trace name context forever,level 12;
        关闭方法
            1. alter session set events '10046 trace name context off;
            2. oradebug event 10046 trace name context off;

如何查看执行计划
    从最开头一直连续往右看，直到看见并列的位置，对于不并列的，靠右的先执行，对于并列的从上往下看，上面的先执行

执行计划 
    与表访问相关的执行计划
        全表扫描在执行计划中对应的关键字是table access full 
        rowid扫描对应的执行计划的关键字为table access by user rowid 或table access by index rowid (取决于SQL计划的关键字和目标表中是否有索引)

    与B树索引相关的执行计划（列值不能为空值 not null）
        索引唯一性扫描对应关键字为index unique scan
            近适用于where条件中是等值查询的SQL语句，其返回结果至多只有一条
        索引范围扫描对应关键字为index range scan
            目标SQL语句中where条件有一定的查询范围如between <  > >= <=等，同等搜索条件下范围扫描至少会比唯一性扫描的逻辑读次数多一次
        索引全扫描对应关键字为index full scan
            按照顺序依次对索引进行扫描，该方法既能对扫描结果达到排序的效果，又能同时避免对该索引值列真正的排序
        索引快速全扫描对应关键字为index fast full scan
            此方法只适用于CBO，可使用多块读，也可以并行执行，返回的结果不一定是有序的
        索引跳跃式扫描对应关键字为index skip scan
            此方法适用于where条件中没有对索引所在前导列指定条件，而对索引其他列指定条件时，，此方法适用于所有的复合索引

    与位图索引相关的执行计划
        创建位图索引关键字 create bitmap 索引名 on 表名(列名)
        优势：
            1. 被索引的列的distinct值较少，位图索引更节省存储空间
            2. 在多个列上创建索引，同等条件下更节省存储空间
            3. 快速处理一些包含各种and或or的条件查询的事情了
        适用条件
            1. 数据相同量大，相同量占总量比例高

        位图索引单键值扫描 bitmap index single value   
        位图索引范围扫描 bitmap index range scan
        位图索引全扫描 bitmap index full scan
        位图索引快速全扫描 bitmap index fast full scan
        位图按位与 bitmap and 
        位图按位或 bitmap or
        位图按位减 bitmap minus

    与表连接相关的执行计划
        排序合并连接对应的关键字是sort join和merge join
        嵌套循环连接对应的关键字是 nested loops
        哈希连接对应的关键字是 hash join 
            哈希半连接 hash join semi
        与反连接所对应的关键字是anti 连接方法不同对应的关键字可分为sort join anti, merge join anti, nested loops anti
        与半连接所对应的关键字是semi 连接方法不同对应的关键字可分为sort join semi, merge join semi, nested loops semi
            半连接会对连接结果进行必要的去重，即对表执行半连接的查询计划时会自动对查询结果进行必要的去重

    其他执行计划
        and-equal又称index merge,指如果where条件里出现了多个针对不同列的等值条件，且这些列上都有单键值的索引，则Oracle会以相应的单个
    等值条件去分别扫描这些索引，然后合并这些单个索引所得到的rowid集合，在从这些集合中筛选值相同的rowid再用筛选过的这些rowid回表得到目标
    SQL的最终执行结果
        and_equal对应关键字为and_equal

        index join 
        对应关键字为index join 

        视图合并view
        对应关键字为view
            如果能做视图合并SQL计划里不一定会出现view关键字，若不能做视图合并SQL计划里一定会出现view关键字，主要看谓词信息(prediacte 
        information)里面提示的内容

        filter过滤是一种改良的嵌套循环连接
        
        sort排序，通常以组合方式出现，比如下列几种
            1. sort aggreate 不一定进行排序
            2. sort unique              是否进行排序主要看统计信息中sorts(memory)和sorts(disk),上同，下同
            3. sort join 
            4. sort group by 
            5. sort order by 
            6. buffer sort 不一定进行排序 /验证是否排序，需要根据目标SQL真实执行计划中的#key值来确定，若值大于0则进行了排序

        union/union all 联合查询
            union：以并集的方式将连个表合并，且做好去重和排序
            union all：以并集的方式将表合并，不会进行去重和排序

        concat
            concat就是in_list扩展或or扩展
            执行计划中对应的关键字是concatenation
            in-list iterator  in-list迭代执行计划中对应的关键字为 inlist iterator

        层次查询(hierarchical queries)
            connect by 


稳定执行计划
    使用SPM 或者SQL profile来稳定执行计划

    SQL profile直译为SQL 概要  （被动执行）
    目的：
        1. 稳定执行计划
        2. 在不能修改目标SQL的SQL文本的情况下使目标SQL语句按指定的执行计划执行
    分类：
        automatic类型
            可以在不更改目标SQL的情况下更改其执行计划
        manual类型
            可以在不更改目标SQL的情况下更改其执行计划，同时可以很好的稳定目标SQL的执行计划
    
    SPM SQL PLAN Management  (主动稳定执行计划，且可以持续更新计划)
        启用后每一个SQL都会存在对应的SQL plan baseline，若有多个执行计划就有多个SQL plan baseline ，
        dba_sql_plan_baselines中列enabled和accepted用来判断SQL plan baseline所对应的执行计划能否被使用
        若enabled accepted的值均为yes则对应的SQL plan baseline的执行计划才能被启用，若有多个值为yes的SQL plan baseline则Oracle
        会从中选择成本值最小的执行计划来执行该SQL语句

        启用方式
            自动捕获： 
                optimizer_capture_sql_plan_baselines此参数用于控制是否开启自动捕获SQL plan baseline，默认为false,不捕获
                    将其值设为true之后Oracle会对此参数影响的范围内所有重复执行的SQL自动捕获SQL plan baseline，且第一次捕获的SQL
                    值均为yes
                optimizer_use_sql_plan_baselines此参数用于控制是否启用SMP ，默认值为true启用，此参数可以在会话和系统
                    级别修改
        更新执行计划可将要执行计划的enabled和accepted的值设为yes，将正在执行的计划中的值设为no即可


查看当前session的session id 
    select sid from V$mystat where rownum<2;
查看当前session id对应的session address 
    select saddr from V$session where sid=144;
查看当前session address产生的transaction总数
    select count(*) from V$transaction where ses_addr='';
查看当前session产生的transaction锁住的对象总数
    select count(*) from V$locked_object;
查看当前transaction 锁住的对象的object id
    select object_id from V$locked_object;
查看object id所对应的对象信息
    select owner,object_name from dba_objects where object_id=xxx;

清空共享池
    alter system flush shared_pool;


库缓存（library cache）：是共享池中的一块内存区域，主要作用是缓存刚刚执行过的SQL语句和pl/sql语句所对应的执行计划、解析树、pcode、
mcode等对象，当同样的语句再次被执行的时候，就可以利用已经缓存在库缓存的相关对象，无需从头开始，提高了语句在重复执行时的效率
    整个库缓存可以看作是由一组hash bucket所组成，每一个hash bucket都对应不同的哈希值，对单个hash bucket而言，其存储的就是哈希值相同的所有库缓存对象句柄
  同一个hash bucket中不同的库缓存对象句柄之间用指针联系起来，同一个hash bucket中不同的库缓存对象句柄之间组成了一个库缓存对象句柄链表
    库缓存对象library cache object：所有的库缓存对象都是以库缓存对象句柄的结构存储在库缓存中，Oracle通过访问相关的库缓存对象句柄
  来访问对应的库缓存对象
    库缓存对象句柄library cache object handle：以哈希表的方式存储在库缓存中，Oracle通过相关的哈希运算存储访问对应的库缓存对象句柄
        常用属性介绍
            name：表示库缓存对象句柄对应的库缓存对象的名称，若是SQL语句对应的库缓存对象句柄，则name的值就是该SQL的SQL文本
                若是表对应的库缓存对象句柄，则那name的值就是该表的表名
            namespace：表示库缓存对象句柄对应的库缓存对象所在的分组名，不同类型的库缓存对象所对应的库缓存对象句柄的namespace值
                可能相同
    库缓存对象句柄链表library cache object handles：
    data heap是库缓存中一块连续的内存区域，由Oracle动态分配，大小不是固定不变的，一个库缓存对象有多个data heap，但每个data heap之间是独立的，没有关联关系


cursor游标与绑定变量
    游标分类
        shared cursor：指缓存在库缓存里的SQL语句和匿名PL/SQL语句所对应的库缓存对象，对应库缓存对象句柄的namespace值为crsr,存储于SGA的库缓存里
        shared cursor是共享的，任意会话，用户都可以访问
            分类：
                parent cursor父游标：目标SQL的SQL文本会存储在其对应的库缓存对象句柄的属性name中，
                child cursor 子游标：目标SQL的解析树和执行计划存储在其对应的库缓存对象句柄的heap6中
            Oracle数据库里，任意一个目标SQL一定会同时对应两个shared cursor，分别为parent cursor和child cursor,其中parent cursor存储该SQL的SQL文本信息
          child cursor存储该SQL的解析树和执行计划，这种双游标的方式可以有效降低对应hash bucket中库缓存对象句柄链表的长度
            通过V$sqlarea视图可以查询到目标SQL的游标数，列version_count的值表示某个parent cursor所拥有的child cursor的数量
                select sql_id,version_count from V$sqlarea where ....;
            通过V$SQL视图查询目标SQL的所有child cursur，列child_number对应的就是详细信息
                select plan_hash_value,child_number from V$sql where sql_id='xxxx';
            通过V$SQL视图查询目标SQL的parent cursor的库缓存对象句柄地址
                select plan_hash_value,child_number,address from V$sql where sql_id='xxxx';
    
        session cursor 用于当前session中解析和执行SQL，存储在PGA中
            与shared cursor的区别
                1. session cursor与session是一一对应的，不同session之间的session cursor之间无法共享
                2. session cursor是有生命周期的，其在使用过程中至少会经历一次open,parse,bind,execute,fetch和close中的一个或多个，当其被使用后是否会缓存
              在相应session的PGA中，有参数session_cached_cursors的值是否大于0决定
                    若参数session_cached_cursors的值等于0，那么session_cursor就会正常执行close操作。
                    若在当前的session的PGA中找不到匹配的缓存session cursor，但在库缓存中找到了匹配的parent/child cursor，则Oracle会新建一个session cursor
                  并重用刚刚匹配到的parent/child parent,此过程为软解析
                3. 以哈希表的方式缓存在PGA中，其执行机制和shared cursor一致：先根据目标SQL的SQL文本的哈希值去PGA中相应的hash bucket中找匹配session cursor
              若匹配不到，Oracle会新生成一个session cursor和一对shared cursor(存储能被所有session共享，重用的内容)，session cursor会经历一次open,parse,
              bind,execute,fetch和close中的一个或多个阶段

              相关参数解析：
                1.open_cursors：用于设定单个session中同时能够以open状态存放的session cursor的总数，若超过该总数，Oracle会报错ORA-1000：maximum open
              cursors exceeded
                    根据V$mystat查询当前会话的sid 
                        select sid from V$mystat where rownum<2;
                    根据V$open_cursor视图查询当前会话的所有open状态的或者被缓存的session cursor的总数
                        select count(*) from V$open_cursor where sid=xxxx;
                    根据V$sysstat查询当前数据库中所有以open状态存在的session cursor的总数
                        select name,value from V$sysstat where name='opened cursors current';
                2. session_cached_cursors：用于设定单个session中能够以soft closed状态存放的session cursor的总数，即单个session能在PGA中缓存的总数
                    此参数Oracle通过LRU算法来动态管理存储在其中的内容
                    根据SQL语句，会话的sid和V$open_cursor视图来查询PGA中session cursor的状态
                        select cursor_type from V$open_cursor where sql_text='xxx'/sql_text like 'xxxx'  and sid=xxxx;
                        状态显示为session cursor cached才是理想的缓存类型
                3. cursor_space_for_time(此参数仅对Oracle10g及以前的版本有用)：其默认值为false，一旦执行完目标SQL之后其对应的状态就不是execute(执行状态)了
              那么此时SQL所对应的child cursor就不能pin(锁)在库缓存中了，也就是说Oracle会释放该SQL所对应的child cursor上的library cache pin同时意味着该SQL
              对应的解析树和执行计划就可以被置换出库缓存了
        
        对应关系
            1. 一个session cursor只能对应一个shared cursor，一个shared cursor可以对应多个session cursor
            2. Oracle在解析和执行目标SQL时，始终会先去当前的session的PGA中查找是否有配备的缓存session cursor
            3. 若在当前的PGA中找不到匹配的缓存session cursor，Oracle就会去库缓存中寻找是否有匹配的parent cursor，若找不到Oracle会新生成一个session cursor
          和一对shared cursor。若找到匹配的parent child但找不到匹配的child cursor则Oracle会生成一个session cursor和一个child cursor，并将新生成的child 
          cursor挂在之前匹配的parent下面。上述的两种条件都是硬解析
            4. 若在当前的PGA中找不到匹配的缓存session cursor，但是在库缓存中找到了匹配的parent/child cursor，此时Oracle会生成一个新的session cursor并重用
          刚才匹配的parent/child cursor 此过程对应为软解析
            5. 若在当前的session的PGA中找到了匹配的session cursor，则通过该session cursor直接访问到该SQL对应的parent/child cursor。此过程为软软解析

    硬解析（hard parse）
        分类：
            1. 在库缓存中找不到匹配的parent cursor，此时Oracle会从头解析目标SQL，并重新生成一个parent cursor和child cursor并挂在对应的hash bucket
            2. 匹配到parent cursor但匹配不到child cursor,此时Oracle会从头解析SQL新生成一个child cursor并 将其挂在相应的parent cursor
        危害：
            1. 会导致shared pool latch的争用，会影响系统的性能和可扩展性（通常表现为CPU占用率居高不下）
                Oracle必须要在shared pool中分配出一块内存区域用于存储新产生的child cursor而这一动作是需要一定的shared pool latch来完成
                latch的作用之一就是保护共享内存的分配
            2. 导致库缓存相关latch（如 library cache latch）和mutex的争用
                硬解析需要扫描hash bucket中库缓存对象句柄链表，这一动作需要一定的library cache latch来完成
                latch的另一个作用就是用于共享SGA内存结构的并发访问控制
                muetx是一种轻量级的latch主要用于共享SGA内存结构的并发访问控制，其描述事件如 cursor:pin S  cursor:pin X  cursor:pin S wait on X 
                cursor:mutex S  cursor:muetx X  library cache:muetx X等
            硬解析会先持有library cache latch，并且在不释放library cache的情况下再持有shared pool latch以便从shared pool中申请分配内存，申请成功后会
          释放shared pool latch最后再释放library cache latch 
            
    软解析（soft parse）
        是指oracle在执行目标SQL时，在库缓存（library cache）中找到匹配的parent cursor和child cursor，并将其存储在child cursor中的
      解析数和执行计划拿来直接使用无须从头开始解析的过程
        与硬解析相比下的优势
            1. 不会导致shared pool latch的争用，会影响系统的性能和可扩展性（通常表现为CPU占用率居高不下）
            2. 软解析也可能会导致库缓存相关latch（如library cache latch）和mutex的争用，但软解析持有库缓存相关latch的次数要少，且
          持有时间较短，其造成的危害较硬解析来说小的多，也少的多
        
    软软解析：将一个使用过的session cursor设为soft closed同时将其缓存在当前session的PGA中，再去做parse bind execute fetch，此过程称为软软解析
        与软解析相比的有点
            1. 对session cursor的使用方面比软解析要好，软软解析省去了一个关闭现有session cursor和新建一个session cursor所耗费的资源和时间
            2.对库缓存相关latch的争用方面会比软解析要好，缓存在PGA中的session cursor所在的hash bucket中已经存储了目标SQL的parent的库缓存对象句柄地址

    建议：OLTP类型的系统在执行目标SQL时使用软解析，系统相较使用硬解析时，系统的性能和可扩展性会有显著提示