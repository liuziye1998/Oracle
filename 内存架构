Oracle数据库内存结构简介
    当实例启动时，Oracle数据库分配内存区，并启动后台进程，内存区存储如下信息：
        1.程序代码
        2.有关每个已连接的会话信息，无论其是否处于活动状态
        3.在程序执行期间所需要的信息，例如：正在索引数据的查询的当前状态
        4.在多个进程直接被传递和共享的信息，如，锁信息
        5.缓存数据，如数据库和重做记录等，它们也存在于磁盘上

与Oracle数据库相关联的基本内存结构
    1.系统全局区（SGA）
        SGA是一组称为SGA组件的共享内存结构，其中包含一个Oracle数据库实例的数据和控制信息,SGA由所有服务器进程和后台进程共享，例如
    SGA中存储的数据包括数据库缓存和共享SQL区
    2.程序全局区（PGA）
        PGA是一个非共享的内存区域，其中包含专门供某个Oracle进程使用的数据和控制信息，Oracle进程启动时Oracle会为其创建PGA。每个服
    务器进程和后台进程都存在一个PGA，所有PGA的集合称为实例PGA或总实例PGA，数据库初始化参数设置实例PGA的大小，而不是单个PGA的大小
    3.用户全局区（UGA）
        与某个用户会话相关联的内存区
    4.软件代码区
        软件代码区是用来存储正在运行或可能要运行的代码的那部分内存。Oracle 数据库代码通常存储在与用户程序不同的位置， 一个更专门或
    更受保护的位置。
    
Oracle数据库内存管理
    内存管理涉及维护 Oracle 实例内存结构的最优大小，以满足数据库的变更需求。Oracle 数据库基于与内存相关的初始化参数设置来管理内存，
内存管理的基本选项如下所示
    1.自动内存管理
        指定实例内存的目标大小，数据库实例自动优化到这个目标内存大小，根据实际需要在SGA和PGA之间重新分配内存
    2.自动共享内存管理
        这种管理模式是部分自动化的。设置一个 SGA 的目标大小，然后设置 PGA 总目标大小，或单独管理 PGA 的各个工作区。
    3.手工内存管理
        你不必设置总的内存大小，但您需要设置许多初始化参数，以单独管理SGA和PGA实例中的各个组件。
    若使用数据库配置助手（DBCA）来创建数据库并选择了基本安装选项，则默认使用自动内存管理

用户全局区概述：
    用户全局区（UGA）是为会话变量分配的会话内存，实际上UGA存储了会话状态
    如果某个会话将 PL/SQL 包加载到内存，则在 UGA 中包含 包 状态 ，即是所有包变量在某个特定的时刻所存储的值集
    OLAP 页面缓冲池也存储在 UGA 中。该池管理相当于数据块的 OLAP 数据页面。页面缓冲池在启动一个 OLAP 会话时分配，并在该会话结束时
释放。每当用户查询一个多维对象（如立方体）时，就会自动打开一个 OLAP 会话
    UGA 必须在数据库会话的整个存活期间是可用的。由于这个原因，当使用共享服务器的连接时，UGA 不能存储在 PGA 中，因为 PGA 是特定于单
个进程的。因此，当使用共享服务器的连接时， UGA 被存储在 SGA 中，以使任何共享服务器进程都能访问它。在使用专用服务器的连接时，UGA 存
储在 PGA 中。

程序全局区概述：
    PGA 是特定于一个操作系统进程或线程的内存区，且不和系统上的其他进程或线程共享。由于PGA 是特定于进程的，所以它决不会在 SGA中分配
    PGA 是包含某个专用或共享服务器进程所需的会话变量的内存堆。服务器进程在需要时会在 PGA 中分配内存结构
    PGA被细分为多个不同区域：
        私有SQL区
            私有 SQL 区保存了有关某个已解析的 SQL 语句的信息，和其他特定于会话的信息。当服务器进程执行 SQL 或 PL/SQL 代码时，
        该过程使用其私有SQL 区域，来存储绑定变量值、 查询执行状态信息、和查询执行工作区

        游标是指向某个特定的私有 SQL 区的一个名称或句柄。你可以将游标看成是一个从客户端指向服务器端状态信息的指针。游标与私有SQL
     区密切相关，这两个术语有时可以互换使用。
            私有SQL分为以下几个区域
                1.运行时区域
                    此区域包含查询执行状态信息，例如，运行时区域会跟踪到目前为止在全表扫描中检索到的行数
                    Oracle 数据库将创建运行时区域，作为一个执行请求的第一步。对于 DML 语句，其运行时区域将在 SQL 语句关闭时被释放
                2.持久区域
                    此区域包含绑定变量的值，绑定变量是执行SQL语句时，在运行时提供给SQL语句的值，仅当关闭该游标时，持久区域才别释放
                客户端进程负责管理私有 SQL 区。虽然客户端进程可以分配的私有SQL区数量由初始化参数 OPEN_CURSORS 限制，但私有SQL区
            的分配和释放主要取决于应用程序
                虽然大多数用户依靠数据库实用程序的游标自动处理机制，但 Oracle 数据库编程接口仍为开发人员提供了对游标更多的控制。
            一般情况下，应用程序应关闭所有打开的且不再使用的游标，以释放持久区域，并最小化应用程序用户的内存需求
       SQL工作区
            工作区是在 PGA 中为内存密集型操作分配的私有内存区
        如果要由该运算符处理的数据量太大，不能在工作区中完成，则 Oracle 数据库会将输入数据分成更小的片断。这样一来，数据库先在内存
        中处理一些数据片断，而将其余数据写入到临时磁盘存储，以待后续处理，
            通常，更大的工作区可以显著提高操作性能，但这是以更多的内存消耗为代价的。理想的情况是，工作区的大小足以容纳输入的数据，
        而由其关联的SQL 运算符分配辅助内存结构。否则，响应时间会增加，因为输入数据的一部分必须被缓存到磁盘上。在极端情况下，如果工
        作区的大小相比输入数据的大小显得过小，则数据库必须来回多次倒腾这些数据片断，极大地增大了响应时间

    在专用和共享服务器模式中使用PGA
        PGA 内存分配取决于数据库是使用专用的还是共享的服务器连接
    
系统全局区概述
    SGA 是一个可读写的内存区，与 Oracle 后台进程一起组成数据库实例。所有以用户名义执行的服务器进程，都可以读取 SGA 实例中的信息。
在数据库操作过程中，有几个进程会对 SGA 进行写入操作
    服务器和后台进程并不驻留在 SGA 中，而是存在于单独的内存空间
    除重做日志缓冲区外，所有 SGA 组件按称为 颗粒的连续内存单元来分配和释放空间。颗粒大小是特定于平台的，由 SGA 的总大小决定。
    每个数据库实例都有其自己的 SGA。当实例启动时 Oracle 数据库自动为其SGA 分配内存，并在该实例关闭时回收内存

    最重要的SGA组件如下所示
        1.数据库缓冲区高速缓存
            也称缓冲区高速缓存，是用于存储从数据文件读取的数据块副本的内存区域。缓冲区是缓冲区管理器用来暂时缓存当前或最近使用的数
        据块的主内存地址。所有同时都连接到一个数据库实例的用户，以共享方式访问缓冲区高速缓存。
            Oracle中缓冲区高速缓存的作用
                1.优化物理I/O
                    数据库更新缓存中的数据块，并将有关更改的元数据存储在重做日志缓冲区，提交之后，数据库将重做缓冲区写入磁盘，但不
                一定会立即将数据块写入磁盘。相反，数据库写入器 (DBWn) 在后台执行惰性写入操作
                2.将频繁访问的块保持在缓冲区高速缓存中，而将不常存取的块写到磁盘   
                    当启用了数据库智能闪存高速缓存（flash 高速缓存）时， 缓冲区高速缓存的一部分可能驻留在闪存缓存中。此缓冲区高速
                缓存扩展存储在 闪存磁盘设备上，这是一种使用闪存的固态存储设备。通过将缓冲区缓存到闪存中，而不是从磁盘读取，数据库
                可以提高性能
                    数据库智能闪存高速缓存仅在 Solaris 和 Oracle 企业 Linux 中可用

            缓冲区状态
                数据库使用内部算法来管理高速缓存中的缓冲区。缓冲区可以处于下列互斥状态之一
                1.未使用的
                    缓冲区可供使用，因为它从未使用过，或者当前未使用。这种类型的缓冲区是数据库最容易使用的
                2.干净的
                    此缓冲区在之前曾被使用过，而现在包含某个数据块在某个时间点的读取一致版本。块包含数据但是干净的，因此它不需要将执行
                    检查点操作。数据库可以订住该块并重用它
                3.脏的
                    缓冲区包含已修改、但尚未写入到磁盘的数据。数据库在重用该数据块之前必须对其执行检查点操作
                每个缓冲区有两种模式，订住的或空闲的，缓冲区被"订住"在缓存中，以便当其被某个用户会话访问时，它不会因为内存不足被换出内存
            多个会话不能在同一时间修改某个已被订住的缓冲区，
                数据库使用复杂的算法以使缓冲区访问高效。 最近最少使用 （LRU ） 列表有一个热端和冷端，同时存在指向同一 LRU 上的脏缓冲区
            和非脏缓冲区的指针。冷缓冲区是最近未被使用的。热缓冲区是被频繁访问并在最近已使用的，从概念上讲，只有一个 LRU， 但为了并发，
            数据库实际上使用多个 LRU

            缓冲区模式
                当一个客户端请求数据时， Oracle 数据库以下列两种模式之一从数据库缓冲区高速缓存中检索缓冲区
                    1.当前模式
                        当前模式获取，也称为数据库块获取，这是一种对当前已出现在缓冲区高速缓存中的块的检索。例如，如果一个未提交事务已
                    更新某个块中的两行，则当前模式获取会检索这个具有未提交行的块。数据库最常使用数据库块获取的情况是在修改语句期间，它只
                    需更新块的当前版本。
                    2.一致模式
                        一致读取获取是对某个块的一致读取版本的检索。此检索可能会使用撤消数据。例如，如果一个未提交事务已更新某个块中的
                    两行，而在另一个独立会话中的查询请求该块，则数据库使用撤消数据来创建该块的一个读取一致版本（称为一致读取克隆）,它不
                    包括未提交的更新。通常，查询以一致模式检索块

            缓冲区I/O
                逻辑 I/O，也称为缓冲区I/O，指的是读取和写入缓冲区高速缓存中的缓冲区。当在内存中找不到请求的缓冲区时，数据库将执行一个物
            理 I/O，将缓冲区从闪存缓存或磁盘复制到内存，然后再执行一个逻辑 I/O，以读取缓存的缓冲区

            缓冲区写出
                数据库写入器 (DBWn) 进程定期将冷的、脏的缓冲区写入磁盘。DBWn 在以下情况下会将缓冲区写出
                    1.服务器进程找不到干净到的缓冲区
                        随着缓冲区变脏，可用缓冲区的数量就会减少。如果该数值低于一个内部阈值，而又需要干净的缓冲区，则服务器进程将通知
                    DBWn 执行写出操作
                    数据库使用 LRU 来确定哪些脏缓冲区被写出。当脏缓冲区到达 LRU的冷端时，数据库将其从 LRU 上移出到 写 出 队列。DBWn 
                    将队列中的缓冲区写到磁盘，如果可能使用多块写，则用之。此机制可以防止LRU 尾端被脏缓冲区塞满，并保证有干净的缓冲区
                    可供重用
                    2.数据库必须推进检查点，即重做线程中进行实例恢复的起点
                    3.表空间被更改为只读状态，或脱机

            缓冲区读取
                当干净的或未使用的缓冲区的数量变得很少时，数据库就必须将某些缓冲区从缓冲区高速缓存删除。其算法取决于是否启用了闪存缓存
                    1.禁用了闪存高速缓存
                        数据库中根据需要覆盖并重新利用每个干净的缓冲区。如果以后需要重用被覆盖的缓冲区，则数据库必须从磁盘重新读取。
                    2.启用了闪存高速缓存
                        DBWn 将干净缓冲区的正文写入到闪存缓存，使其内存中的缓冲区可以被重用。数据库在主内存中保留 LRU 列表的缓冲区头，
                    以跟踪在闪存缓存中的缓冲区体的状态和位置。如果以后需要该缓冲区，则数据库可以从闪存缓存中读取它，而不用从磁盘读取
                当客户端进程请求一个缓冲区时，服务器进程在缓冲区高速缓存中搜索缓冲区。如果数据库在内存中找到缓冲区，则发生 缓存命中。
                搜索顺序如下所示：
                    1.服务器进程在缓冲区高速缓存中搜索整个缓冲区
                        如果该进程发现整个缓冲区，则数据库对此缓冲区执行一个逻辑读取
                    2.服务器进程在闪存缓存 LRU 列表中搜索缓冲区头
                        如果该进程找到了缓冲区头，则数据库执行一个 优化的物理读取，将缓冲区正文从闪存缓存读入到内存内缓存
                    3.如果该进程没有在内存中找到该缓冲区（ 缓存未命中），则服务器进程将执行以下步骤：
                        1.将该块从数据文件复制到内存中 （ 物理读取）
                        2.对已读入到内存中的缓冲区执行一个逻辑读取
                    扩展的缓冲区高速缓存包括包含整个缓冲区的内存内缓冲区缓存，和包含缓冲区正文的闪存缓存。
                    一般情况下，通过缓存命中访问数据比通过缓存未命中要快。 缓冲区高 速缓存命中率用于测量数据库在缓冲区高速缓存中找到请
                求的块，而不需要从磁盘中读取的比率
                    数据库可能从数据文件或临时文件执行物理读取。在数据文件读取之后，会紧跟着有逻辑 I/O。临时文件读取发生在当内存不足时，
                迫使数据库将数据写入一个临时表，稍后又将其读回。这种物理读取会绕过缓冲区高速缓存，并不会导致逻辑的 I/O

            缓冲区触摸计数
                数据库使用 触摸计数来测量对 LRU 列表上的缓冲区进行访问的频率。这种机制使得当某个缓冲区被订住时数据库可以增加一次计数，
            而不用不断地移动 LRU 列表上的缓冲区
                数据库不会物理地移动内存中的块。此移动只是改变列表上指针的位置
                当缓冲区被订住时，数据库将确定其触摸计数的最后一次递增是何时发生的。如果计数递增发生在超过三秒钟前，则计数将增加1；否则
            计数保持不变。三秒钟规则防止对该缓冲区的一系列突发订住会产生过多计数。例如，一个会话可能会在一个数据块中插入几行，但数据库将
            这些插入作为一个触摸看待
                如果某个缓冲区是在 LRU 的冷端上，但其触摸计数很高，则该缓冲区将移动到热端。如果触摸计数很低，则缓冲区将从缓存中老化移出
            
            缓冲区和全表扫描
                当缓冲区必须从磁盘读入时, 数据库会将缓冲区插入到 LRU 列表的中部。通过这种方式，热块可以保留在缓存中，以使他们不需要再次
            从磁盘读取
                全表扫描顺序读取表高水位（请参阅"段空间和高水位"）下的所有行，这可能引发一个问题。假设表段中块的总大小大于缓冲区高速缓存
            的大小。在此表上的全表扫描可能会清除高速缓存，致使数据库不能将频繁访问的块维持在高速缓存中
                大型表的完全扫描导致将块读入数据库高速缓存，与其他类型读取的处理方式有所不同。（在完成扫描之后，这些缓冲区中的）块可以被
            立即重用，以防止该扫描真正地清理缓冲区高速缓存
                在某些少有的情况下，若默认行为不是你所希望的，您可以更改表的CACHE 属性。在这种情况下，数据库不会在缓存中强制或订住块，
            而是与任何其他块相同的方式，让其从高速缓存中老化移出。使用此选项时要小心，因为大表的全表扫描可能会将大部分的其他块从缓存中清
            理出去

            缓冲池
                缓冲池是缓冲区的集合。数据库缓冲区高速缓存被划分为一个或多个的缓冲池
                您可以手动配置多个单独的缓冲池，要么将数据保留在缓冲区高速缓存中，或在使用了数据块之后、使缓冲区立即可用于新的数据。然后
            你可以将模式对象分配给适当的缓冲池，以控制数据块如何从缓存中老化移出
                可能的缓冲池如下所示：
                1.缺省池
                    该池是块通常被缓存的地方。除非您手动配置单独的池，默认池将是唯一的缓冲池
                2.保留池
                    该池用于被频繁访问的块，使其不会由于缺省池的空间不足而被移出。保留缓冲池的目标是将对象保留在内存中，从而避免I/O操作
                3.循环池
                    该池用于不被频繁使用的块。循环池防止对象在缓存中占用不必要的空间

        2.重做日志缓冲区
            重做日志缓冲区是 SGA 中的一个循环式缓冲区，用来存储对数据库所做更改的重做条目。重做条目包含用于重建（或重做）由 DML 或 DDL 
        操作对数据库所做更改所需的信息。数据库恢复将重做条目应用到数据文件，以重建丢失的更改
            Oracle 数据库进程将重做条目从用户内存空间复制到 SGA 的重做日志缓冲区中。重做条目占用缓冲区中连续、顺序的空间。日志写入器
        (LGWR)后台进程将重做日志缓冲区写入磁盘上的活动联机重做日志组
            LGWR 进程将重做信息顺序写入磁盘，而 DBWn 进程将数据块分散写入磁盘。分散写入往往要比顺序写入慢得多。LGWR 使用户能够避免等待
         DBWn完成其缓慢的写入，为数据库提供了更好的性能
            LOG_BUFFER 初始化参数指定了 Oracle 数据库在缓冲重做条目时所能使用的内存量。与其他的 SGA 组件不同，重做日志缓冲区和固定的 
        SGA 缓冲区不按颗粒划分内存

        3.共享池
            共享池缓存各种类型的程序数据。例如，共享池存储已解析的 SQL、PL/SQL 代码、 系统参数、和数据字典信息。几乎数据库中发生的每个
        操作都涉及到共享池
            共享池包含以下组件：
                1.库缓存
                    库缓存是存储可执行 SQL 和 PL/SQL 代码的共享池内存结构。此缓存包含共享 SQL 和 PL/SQL 区，以及锁和库缓存句柄之类的控制
                结构。在共享服务器体系结构中，库缓存还包含私有 SQL 区
                    在执行 SQL 语句时，数据库将尝试重用以前执行过的代码。如果在库缓存中存在该 SQL 语句的已解析表示形式，并且是可以共享的，
                则数据库会重用该代码，这称为软解析或库缓存命中。否则，数据库必须为应用程序代码建立一个新的可执行版本，这称为硬解析或库缓存
                未命中

                    数据库所运行的每个 SQL 语句，会存在于下列两种 SQL 区之一
                        1.共享SQL区
                            数据库使用共享 SQL 区来处理 SQL 语句第一次发生时的情况。该区域对所有用户可访问，并包含语句的解析树和执行计划。对
                        于每个唯一的语句，只存在一个共享 SQL 区
                        2.私有SQL区
                            每个发出 SQL 语句的会话在其 PGA 中有一个私有 SQL 区。提交同一语句中的每个用户都分别有一个私有 SQL 区，但都指向
                        同一共享 SQL 区。因此，在多个单独 PGA 中的私有 SQL 区可能与同一共享 SQL 区相关联

                    当应用程序提交类似的 SQL 语句时，数据库会自动决定怎么做。数据库会同时考虑从用户和应用程序直接发出的语句，及其它语句从
                内部发出的递归SQL 语句
                数据库执行以下步骤
                    1. 检查共享池，看是否存在某个语法和语义上都相同的语句的共享SQL 区
                        1.如果存在这样一个相同的语句，则数据库为该语句的后续新实例使用这个共享 SQL 区，从而减少内存消耗
                        2.如果不存在这样一个相同的语句，则数据库在共享池中分配一个新的共享SQL区。语法相同、但语义不同的语句会使用一个子游标
                    在这两种情况下，用户的私有 SQL 区都指向包含语句和执行计划的共享 SQL 区
                    2.为该会话分配一个私有 SQL 区
                        私有 SQL 区的位置取决于该会话所建立的连接。如果会话是通过共享服务器连接的，则该私有SQL区中的一部分被保存在SGA中
                
                程序单元和库缓存
                    库缓存包含 PL/SQL 程序和 Java 类的可执行形式。这些项目统称为程序单元
                    数据库分配一个共享区来保存 PL/SQL 程序的已解析和已编译形式。数据库分配一个私有区域来保存运行该程序特定于会话的值，包括
                    为执行 SQL 的本地、全局、包变量、和缓冲区等。
                
                共享池 中 的内存 分配和重用
                    当解析新的 SQL 语句时，数据库将分配共享池内存。内存大小取决于语句的复杂性
                数据库还在以下情况下从共享池中删除共享 SQL 区：
                    1.如果为表、 表簇、或索引收集了统计信息，则默认情况下，数据库在一段时间后，会逐步删除所有包含引用了已分析对象的语句的共享
                SQL 区
                    2.如果一个模式对象在某个 SQL 语句中被引用，而之后此对象被某个DDL 语句修改，则数据库将使这个共享 SQL 区无效
                    3.如果更改了全局数据库名称，则数据库将删除所有共享池信息

            2.数据字典缓存
                数据字典是数据库表和视图的集合，其中包含有关数据库及其结构、用户等参考信息
                指定以下位置来保存字典数据
                    1.数据字典缓存
                        此缓存保存有关数据库对象的信息。此缓存也称为 行缓存，因为它按行、而不是按缓冲区保存数据
                    2. 库缓存
                所有服务器进程都共享这些缓存来对数据字典信息进行访问

            3.服务器结果缓存
                与缓冲池保存数据块不同， 服务器结果缓存保存的是结果集。服务器结果缓存包含 SQL 查询结果缓存和 PL/SQL 函数结果缓存，它们共享
            相同的基础结构
                客户端结果缓存不同于服务器结果缓存。客户端缓存在应用程序级别配置，并位于客户端内存中，而不是位于数据库内存中
                SQL查询结果缓存
                    数据库能在 SQL 查询结果高速缓存中存储查询和查询片段的结果，将此缓存结果用于将来的查询和查询片段。
                PL/SQL函数结果缓存
                    PL/SQL 函数结果缓存存储函数的结果集。若不使用缓存功能，每次调用花 1 秒钟的函数，调用该函数 1000 次将花时间 1000 秒。
                而缓存后，以相同的输入调用函数1000次总共仅需要时间1秒。对于在相对静态的数据上被频繁调用的函数，结果缓存是一个很好的选择
             4.保留池
                保留 池是共享池中的一个内存区， Oracle 数据库使用它来分配大的连续内存块
                从共享池中分配内存是按大块执行的。大块使得大型对象(超过 5 KB)可以被加载到缓存中，而不需要一个单一的连续区域。这样一来，
                数据库中由于碎片引起的连续内存不足的可能性降低了
        4.大池
            大池是一个可选的内存区域，它所提供的内存分配往往比共享池分配的内存更大
            大池可以提供以下大内存分配
                1.共享服务器的 UGA，和 Oracle XA 接口 （用于与多个数据库进行交互的事务）
                2.并行执行语句中使用的消息缓冲区
                3.恢复管理器 （RMAN) I/O 从属进程的缓冲区
            通过从大池中为共享 SQL 分配会话内存，数据库可以避免由收缩共享 SQL缓存引起的性能开销。通过为 RMAN 操作、I/O 服务器进程、
        和并行缓冲区等分配大的缓冲区内存，大池可以比共享池更好地满足大型内存请求
            共享池中的保留空间与其它内存分配都使用同一 LRU 列表，而大池与此不同，它根本就没有 LRU 列表。这些被分配的内存片断直到操作
        完成后才会被释放。一旦释放了一个大块内存，其他进程就可以使用它

        5.JAVA池
            Java 池是一个存储 Java 虚拟机 (JVM) 内所有会话特定的 Java 代码和数据的内存区。此内存包括在 调用端迁移到 Java 会话空间的 
        Java 对象
            对于专用服务器连接，Java 池包括每个 Java 类的共享部分，包括方法和只读内存，如代码向量，但不包括每个会话的 Java 状态。
         对于共享服务器Java 池包括每个 Java 类的共享部分，和用于每个会话状态的一些 UGA 。每个 UGA 根据需要增长和缩小，但总的 UGA
        大小必须适应 Java 池空间
            Java 池顾问统计提供有关用于 Java 的库缓存内存信息，并预测 Java 池大小的更改如何影响解析率。当 statistics_level 设置为
         TYPICAL或更高时，Java 池顾问在内部会被打开。这些统计信息在顾问被关闭时会被重置
        6.流池
            流池用于存储缓冲的队列消息，并为 Oracle 流的捕获进程和应用进程提供内存。流池专门由 Oracle 流使用
            如果您没有专门配置流池，则其大小从零开始。池池的大小由 Oracle 流按需动态增长
        7.固定SGA
            固定 SGA 是内部的内务管理区域
            固定的SGA包扩：
                1.有关数据库及其实例状态的一般信息，后台进程需要访问这些信息
                2.进程间通讯的信息，如有关 锁的信息
            固定 SGA 的大小由 Oracle 数据库设置，且不能手动更改。固定 SGA 大小可能会因为版本不同而不同

软件代码区概述
    软件代码区是用于存储正在运行或可以运行的代码的那部分内存，Oracle数据库代码的存储位置通常比用户程序更专用、更受保护
    软件区的大小通常是静态的，其大小只在软件更新或重新安装时才会改变。这些区域所需的大小因操作系统而异
    软件区是只读的，并且可以按共享或非共享方式安装。某些数据库工具，如Oracle Forms 和 SQL*Plus，可以共享安装，但有些却不能。只要可能，
这些数据库代码会被共享，以便所有用户都可以访问它，而无需在内存中存在多个副本，从而减少主内存并改进整体性能。数据库的多个实例可以与同一
台计算机上运行的不同的数据库使用相同的数据库代码区域